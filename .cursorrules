# Challenge Picker - Cursor AI Rules

## Quick Start
```bash
# First time setup (does everything!)
make setup              # Creates .env, generates JWT keys, starts backend, loads data
npm install             # Install frontend dependencies

# Daily development
make start              # Start backend services
make dev                # Start frontend (in separate terminal)
```

## Project Overview
Full-stack application with Nuxt.js frontend (runs locally) and Symfony backend (containerized with Docker). Uses Makefile for universal cross-platform development workflow.

## âš ï¸ MANDATORY: Code Quality Checks

**CRITICAL**: After ANY changes to `backend/` code, you MUST run:

```bash
make cs-fix    # Auto-fix code style
make phpstan   # Run static analysis
# OR
make qa        # Run both at once
```

**Do NOT skip these checks!** They enforce:
- Consistent code style (@Symfony + @PSR12)
- Type safety (PHPStan level max/9)
- No mixed types
- Proper array type specifications

If PHPStan reports errors, fix them before proceeding. Clean code is non-negotiable.

## Architecture Principles

### Backend (Symfony)
- **One Endpoint = One Controller**: Each API endpoint must have its own dedicated controller file
- **Request/Response DTOs**: Every endpoint MUST use dedicated Request and Response objects (DTOs)
- **SOLID Principles**: Follow Single Responsibility, maintain separation of concerns
- **File Naming Convention**: 
  - Controllers: `{Action}{Resource}Controller.php` (e.g., `CreateUserController.php`)
  - Request DTOs: `{Action}{Resource}Request.php` (e.g., `CreateUserRequest.php`)
  - Response DTOs: `{Action}{Resource}Response.php` (e.g., `CreateUserResponse.php`)

### ğŸƒ Tarot-Based Rule System
**See `TAROT.md` for complete documentation.**

The challenge system is based on the 78-card Tarot deck structure:

**Rule Types:**
- **basic** (Minor Arcana - Numbered 1-10): 10 difficulty levels, 1-10 minute durations
- **court** (Minor Arcana - Court Cards): 4 difficulty levels, 10/15/20/25 minute durations
- **legendary** (Major Arcana - 22 cards): Permanent rules, no duration

**Ruleset Structure Limits:**
- **Default Rules**: 0-22 legendary rules (permanent, auto-start)
- **Optional Viewer Rules**: Up to 8 rules maximum (basic or court variants)
- **Total per Ruleset**: Maximum 30 rules (22 default + 8 optional)
- **Concurrent Active**: Players can have 1-10 rules active simultaneously

**Best Practices:**
- âœ… Keep optional rules to 6-8 maximum
- âœ… Mix basic (1-10 min) and court (10-25 min) variants
- âœ… Use legendary rules for permanent challenge identity
- âŒ Don't add redundant rules (Walking Only = No Sprint)
- âŒ Don't use counters for obvious scenarios (pistol counter in pistol-only mode)
- âŒ Don't exceed 8 optional rules (breaks tarot suit concept)

### ğŸ“‹ Category Ruleset Structure (Universal Template)
**When creating rulesets for game categories (Horror, Shooter, RPG, etc.):**

**Structure:**
- **0-2 Permanent Rules** (legendary, auto-start) - Defines the challenge identity
- **4-5 Chaos Rules** (basic/court, optional) - Viewer-controlled difficulty modifiers
- **For Hard Rulesets**: Add "Free Pass" rule to make 6 chaos rules total (balancing tool)

**Examples:**
- **Easy Ruleset**: 0 permanent + 5 chaos rules (viewers build difficulty)
- **Medium Ruleset**: 1 permanent + 5 chaos rules (one core restriction)
- **Hard Ruleset**: 2 permanent + 4 chaos + Free Pass (brutal base, slight relief)
- **Expert Ruleset**: 2 permanent + 6 chaos rules (no mercy)

**Why This Works:**
- Simple and consistent across all categories
- Permanent rules define the challenge (e.g., "No Healing", "Knife Only")
- Chaos rules let viewers customize difficulty in real-time
- Free Pass gives streamers emergency relief on brutal challenges
- Works universally: Horror, Shooter, RPG, Platformer, etc.

**Rule Selection Guidelines:**
- Choose rules that work for 70%+ of games in the category
- Avoid game-specific mechanics (e.g., "No Parry" only works in Souls-likes)
- Mix movement, combat, resource, and challenge rules
- Always include at least one counter rule (Get Hit, Use Item, etc.)

### âš ï¸ CRITICAL: Playthrough API Pattern
**Each user can only have ONE active playthrough at a time.**

**Always use user UUID (from auth) instead of playthrough ID in URLs:**
- âœ… CORRECT: `GET /api/playthrough/active-rules` (uses auth token)
- âŒ WRONG: `GET /api/playthroughs/{id}/active-rules` (requires ID)

**Why?** Users (especially streamers) configure Stream Deck buttons once with their auth token. When they start a new playthrough, buttons continue working without reconfiguration.

**Implementation:**
1. Extract user from JWT token in controller
2. Find user's active playthrough: `WHERE user_uuid = ? AND status = 'active'`
3. If no active playthrough â†’ return appropriate error
4. Operate on that playthrough

**Example:**
```php
$user = $this->getUser(); // From JWT
$playthrough = $playthroughRepository->findActiveByUser($user->getUuid());
if (!$playthrough) {
    return $this->json(['error' => 'No active playthrough'], 404);
}
// Use $playthrough...
```

### Frontend (Nuxt.js)
- Use Composition API with `<script setup>`
- TypeScript for all logic
- Tailwind CSS for styling
- API calls through `/api/` proxy to Symfony backend

## Code Organization

### Symfony Structure
```
backend/src/
â”œâ”€â”€ Controller/          # One file per endpoint
â”‚   â””â”€â”€ Api/            # API controllers grouped here
â”œâ”€â”€ DTO/                # Data Transfer Objects
â”‚   â”œâ”€â”€ Request/        # Request objects for validation
â”‚   â””â”€â”€ Response/       # Response objects for serialization
â”œâ”€â”€ Entity/             # Doctrine entities (database models)
â”œâ”€â”€ Repository/         # Database repositories
â”œâ”€â”€ Service/            # Business logic services
â””â”€â”€ Validator/          # Custom validation constraints
```

### Nuxt Structure
```
.
â”œâ”€â”€ components/         # Reusable Vue components
â”‚   â””â”€â”€ modal/         # Modal components (for dialogs, forms, etc.)
â”œâ”€â”€ composables/        # Composable functions (use*)
â”œâ”€â”€ pages/              # File-based routing
â”‚   â”œâ”€â”€ admin/         # Admin dashboard (content management)
â”‚   â”œâ”€â”€ creator-tools.vue # Creator dashboard (Stream Deck, OBS)
â”‚   â”œâ”€â”€ playthrough/   # Player area (gameplay)
â”‚   â””â”€â”€ ...           # Other pages
â”œâ”€â”€ types/              # TypeScript type definitions
â””â”€â”€ assets/css/         # Global styles
```

### App Structure - Three Tiers
The app is organized into three distinct areas:

1. **ğŸ® Player Area** (Default)
   - Browse games and rulesets
   - Start/manage playthroughs
   - View active rules
   - Standard player experience
   - Routes: `/`, `/games`, `/playthrough/*`

2. **ğŸ›ï¸ Creator Dashboard** (`/creator-tools`)
   - Stream Deck integration
   - OBS Browser Sources
   - Professional streaming tools
   - Setup guides and troubleshooting
   - Route: `/creator-tools`

3. **âš™ï¸ Admin Dashboard** (`/admin/*`)
   - Manage games, rules, rulesets
   - Content moderation
   - User management
   - System administration
   - Routes: `/admin/games`, `/admin/rules`, `/admin/rulesets`

### Component Organization
- **Modal Components**: Extract modals into `components/modal/` when a page file exceeds 400 lines
  - Naming: `{Feature}Modal.vue` (e.g., `GameFormModal.vue`, `ConfirmDeleteModal.vue`)
  - Pass data via props, emit events for actions
  - Keep modal logic self-contained
  - Use v-model for show/hide state when possible

## Development Guidelines

### When Creating New Endpoints
1. Create Request DTO in `backend/src/DTO/Request/`
2. Create Response DTO in `backend/src/DTO/Response/`
3. Create Controller in `backend/src/Controller/Api/`
4. Each controller should:
   - Have ONE action method (typically `__invoke()`)
   - Validate input using Request DTO
   - Return Response DTO
   - Handle errors with proper HTTP status codes

### When Modifying Database Schema
1. Create entities in `backend/src/Entity/`
2. Generate migration: `docker-compose exec php php bin/console make:migration` or `make shell` then `php bin/console make:migration`
3. Review migration file before running
4. Run migration: `make migrate` or `docker-compose exec php php bin/console doctrine:migrations:migrate`

### When Adding Initial Data
1. Create Doctrine Fixtures in `backend/src/DataFixtures/`
2. Use fixture dependencies and references for entity relationships
3. Load fixtures: `make fixtures` or `docker-compose exec php php bin/console doctrine:fixtures:load`
4. Follow existing fixtures as examples (TarotCardFixtures, CategoryFixtures, GameFixtures, RuleFixtures)
5. Game images **are** included in fixtures via `GameImagesData.php` for smooth dev experience

### Game Images
- Game images are stored in `backend/src/DataFixtures/GameImagesData.php`
- Included in fixtures for instant setup - no extra download needed
- Images are base64-encoded 256x256 JPEGs (~20-30KB each)
- To update images: Run `make fetch-icons` to download latest from Twitch/Steam
- Priority: Twitch box art â†’ Steam CDN â†’ Epic (not implemented)
- To export current images: `make export-game-images`

### Category Images
- Category images are stored in `backend/src/DataFixtures/CategoryImagesData.php` (optional)
- Can be fetched from Kick.com with permission: `make fetch-category-icons`
- Images are base64-encoded 256x256 JPEGs
- Each category has a `kick_category` field mapping to Kick.com category names
- To export current images: `make export-category-images`

### When Adding Features
1. Check `ROADMAP.md` for planned features and priorities
2. Update ROADMAP.md when features are completed
3. Write migrations for any database changes
4. Update Doctrine Fixtures if initial data changes

## Development Commands

### Makefile Commands (Recommended)
```bash
# First-time setup
make setup              # Creates .env, generates JWT keys, starts backend, runs migrations, loads fixtures

# Daily workflow
make start              # Start backend services (MySQL, PHP, Nginx)
make stop               # Stop backend services
make dev                # Start frontend dev server (runs locally, not in Docker)

# Database operations
make migrate            # Run database migrations
make fixtures           # Load Doctrine fixtures

# Development tools
make logs               # View backend logs
make shell              # Open bash in PHP container
make clean              # Clean up (WARNING: deletes database)

# Admin management
make admin-list         # List all users and their admin status
make admin-promote      # Promote a user to admin (prompts for Discord ID/email)

# Code quality
make cs                 # Check code style (PHP CS Fixer)
make cs-fix             # Fix code style automatically
make phpstan            # Run static analysis (PHPStan level 6)
make qa                 # Run all quality checks

# Environment setup
make env                # Create backend/.env from backend/.env.dist
make jwt                # Generate JWT encryption keys
```

### Symfony Console Commands
```bash
# Run any Symfony console command
docker-compose exec php php bin/console <command>

# Or use make shell first
make shell
php bin/console <command>

# Common commands
docker-compose exec php php bin/console make:entity
docker-compose exec php php bin/console make:migration
docker-compose exec php php bin/console make:controller Api/CreateUserController
```

### Frontend Commands (Runs Locally)
```bash
# Install packages (frontend runs locally, NOT in Docker)
npm install <package>

# Run dev server
npm run dev             # or 'make dev'
```

## API Response Standards

### Success Response Format
```json
{
  "success": true,
  "data": { /* response data */ }
}
```

### Error Response Format
```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message",
    "details": { /* optional error details */ }
  }
}
```

## Database Management

### Migrations
- Keep migrations consolidated (single comprehensive migration for current schema)
- Generate new migrations only for incremental changes
- Always review migrations before running
- Commands: `make migrate` or `docker-compose exec php php bin/console doctrine:migrations:migrate`

### Fixtures (Initial Data)
- Use Doctrine Fixtures Bundle for all seed data
- Located in `backend/src/DataFixtures/`
- Follow dependency order: TarotCardFixtures â†’ CategoryFixtures â†’ GameFixtures â†’ RuleFixtures
- Use `$this->addReference()` and `$this->getReference()` for entity relationships
- Load with: `make fixtures` or `docker-compose exec php php bin/console doctrine:fixtures:load`
- Reference existing fixtures for examples of proper structure and relationships

## Testing Approach
- Test endpoints using phpMyAdmin (http://localhost:8080) for database inspection
- Test API using browser or Postman at http://localhost:8090
- Frontend available at http://localhost:3000

## Code Quality & Standards

### PHP CS Fixer
- **Check style**: `make cs` - Dry-run to see what would be fixed
- **Fix style**: `make cs-fix` - Auto-fix all code style issues
- **Configuration**: `backend/.php-cs-fixer.php` (custom config only, `.dist.php` removed)
- **Rules**: @Symfony + @PSR12 + custom rules
- **Run before committing** to ensure consistent code style

### PHPStan (Static Analysis)
- **Run analysis**: `make phpstan`
- **Configuration**: `backend/phpstan.neon`
- **Level**: max (9) - strictest type checking
- **Scans**: All files in `backend/src/` (except Kernel.php)
- **Catches**: Type errors, undefined methods, missing return types, mixed types, etc.
- **Run before committing** to catch bugs early

### Quality Assurance Workflow (MANDATORY for backend changes)
1. Write code following architecture principles
2. Run `make cs-fix` to auto-format code (REQUIRED after ANY backend change)
3. Run `make phpstan` to check for type errors (REQUIRED after ANY backend change)
4. Run `make qa` to run both checks at once (RECOMMENDED)
5. Fix any reported issues before proceeding
6. **NEVER skip these steps for backend code!**

### CI/CD Integration (Future)
- Code style check will be enforced in CI pipeline
- PHPStan will block merges if errors found
- Tests will run automatically on push

## Important Notes

### Environment & Configuration
- **NEVER commit `backend/.env`** - Contains secrets and credentials
- **ALWAYS commit `backend/.env.dist`** - Template for other developers
- Use `.env.dist` pattern for all environment templates
- Database credentials are in `docker-compose.yml` (dev only)
- Single root `.gitignore` - Do NOT create separate `.gitignore` files in subdirectories

### Auto-Generated Files
- **ALWAYS clean up redundant auto-generated files** after creating custom configs
- Examples of files to remove when redundant:
  - `.php-cs-fixer.dist.php` (when custom `.php-cs-fixer.php` exists)
  - Default config templates that have been replaced with custom versions
  - Backup/example files from package installations
- Keep project clean - one config file per tool

### Code Standards
- All API routes should be prefixed with `/api`
- Use proper HTTP status codes (200, 201, 400, 401, 404, 500)
- Always validate input data
- Always use type hints in PHP and TypeScript
- **UUIDs**: Use Symfony's `Uuid::v7()` for all UUIDs
  - Time-ordered (better database performance, no index fragmentation)
  - Stored as BINARY(16) via Doctrine's UuidType (more efficient than VARCHAR(36))
  - Auto-generated in entity constructors

### Development Workflow
- Use `Makefile` commands for all common tasks (cross-platform)
- Frontend runs locally (NOT in Docker) for better performance
- Backend runs in Docker (PHP, MySQL, Nginx)
- Use Doctrine Fixtures for seeding data, not custom commands

## Project Structure Standards

### File Organization
```
/
â”œâ”€â”€ Makefile                 # Universal build tool (primary development interface)
â”œâ”€â”€ .gitignore               # Single root .gitignore for entire project
â”œâ”€â”€ docker-compose.yml       # Backend services only (PHP, MySQL, Nginx, phpMyAdmin)
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ .env.dist            # Environment template (COMMITTED to git)
â”‚   â”œâ”€â”€ .env                 # Actual secrets (IGNORED by git)
â”‚   â”œâ”€â”€ src/DataFixtures/    # Doctrine fixtures for seeding data
â”‚   â””â”€â”€ migrations/          # Database migrations (consolidated, single migration for schema)
â”œâ”€â”€ components/
â”‚   â””â”€â”€ modal/               # Extract modals here when page exceeds 400 lines
â”œâ”€â”€ composables/             # Reusable Vue logic
â””â”€â”€ pages/                   # File-based routing
```

### What NOT to Create
- âŒ Platform-specific startup scripts (e.g., `docker-start.sh`, `docker-start.bat`)
- âŒ Custom fixture loading commands (use Doctrine Fixtures)
- âŒ Multiple `.env` variants (`.env.local`, `.env.dev`, etc.)
- âŒ Separate `.gitignore` files in subdirectories
- âŒ Frontend Dockerfile (frontend runs locally)
- âŒ Custom environment setup scripts (use Makefile `make env`)
- âŒ Redundant auto-generated config files (`.php-cs-fixer.dist.php`, etc.)

### What TO Create
- âœ… Makefile targets for new common tasks
- âœ… `.env.dist` for environment templates
- âœ… Doctrine Fixtures in `backend/src/DataFixtures/`
- âœ… Single consolidated migration for schema changes

## Feature Development Workflow
See `ROADMAP.md` for project progress and planned features:
- Track current version and progress to v1.0
- Check priorities: ğŸ”´ Critical | ğŸŸ¡ High | ğŸŸ¢ Medium/Low
- Update status when features are completed: âœ… Complete | ğŸš§ In Progress | â³ Planned
- Review requirements checklist before v1.0 release

